
# 小议现代编程语言


## 对历史的回顾总结

在思考现代编程语言应该做什么之前，可以简单地回顾下过去编程语言做了什么。

更早的先不论；在上世纪70年代早期出现的 C 是一个划时代的发明，它和同期已有的编程语言相比，语言的抽象机制非常成熟、非常有表现力；在上世纪80年代早期又有 C++ ，作为对 C 抽象机制的补足，到此为止编程语言还带有一些传统工业的味道，遵循一条从实验室到工业标准再到各家厂商的具体实现的发展轨迹；

而等到上世纪八十年代后期到上世纪九十年代，进入网络时代（信息时代），涌现了一批小团队甚至个人的语言项目，他们分别是：

+ 1987 - Perl，个人项目，第一个吃到网络红利的脚本语言

+ 1988 - Tcl，个人项目

+ 1991 - Python，个人项目

+ 1993 - Lua, 个人项目

+ 1995 - Java, 三人团队

+ 1995 - JavaScript，个人项目

+ 1995 - PHP，个人项目，又是一个重量级[^10]

等到了二十一世纪，真正值得一提的是 2009 - Go ，和 2015 - Rust。 其中 Go 是一门身体在二十一世纪，而头脑还停留在上个的世纪的语言，我提它就是作为一个反派的对比，来映衬真正的主角： Rust 。 [^12]

### 我们能从 Rust 项目里学到什么

我讲的 Rust 不是因为它没有缺点[^11]，而是因为它是一门真正的现代语言，有着现代语言应有的开发团队规模，现代语言应有的设计，和现代语言应有的完备工具链和生态系统，这是二十一世纪第二个十年，范用型系统编程级语言的模板。

从 Rust 开始，编程语言终于不再是由一个或少数几个人手工作品，而是一个正儿八经的大型项目开发，从 Rust 的源代码组织就可以看出来，传统手工作业的语言它的编译器源代码少到可以很快地过一遍，但是对于 Rust 没有人敢说这个话，这就是一个大型项目的代码结构，不说具体代码了，光是子项目都看不完。

代码多，子项目多本身不是优点，但是它反映了这个项目高度组织化的特点，每一个小的功能都被解耦，分解为颗粒度很细的子项目，供一个小工作组或者根本就是一个人来开发，这样原来被大包大揽干得很糙的活儿，可以被做得好得多、细得多，也只有这样才能适应一个复杂的现代编程语言的开发需求。

本语言项目就从 Rust 的代码组织里学到了很多，这样麻雀虽小，五脏俱全，完全可以把它分为：

1. 词法语法解析的工作；
2. 语义解析的工作；
3. 抽象语法树转换成 LLVM 的工作
4. 交给 LLVM 或者自己为汇编语言封装的抽象 + 汇编语言抽象的特定平台实现


## 一般化分析

按照一般现代工业产品的分析框架，产品功能要追寻客户需求，而卓越的产品不仅满足客户的一般需求，还帮客户创造新的需求，从而引领一个行业的标准。

而编程语言作为非终端的工业产品，它的客户可以分为两类：**直接客户** 和 **终极客户**。

直接客户是指使用编程语言进行编程的人员，而终极客户的定义是递推的，包括使用直接客户所编写产品的客户和终极客户的（相关下游）客户。

### 直接客户

#### 快速启动

首先，编程语言的直接客户也是编写该编程语言的编译器所使用编程语言的终极客户，最好使得编译器易于安装和使用，使得不需要花什么周折[^1]，就马上可以开干。

#### 复杂编译器

让编译器多干活，让程序员少干活，而不是让程序员去干本应该是机器该干的活儿。[^2]

比如，**强自动类型推断** ，没有任何道理去让程序员去手写类型，这里面绝大部分都是很机械的活儿；

再比如，**完备的宏编程机制** ，经典编程模型的抽象能力是很有限的，大型项目是很难绕开宏编程的，如果官方没有提供宏机制、或者提供的宏机制很烂，那大家总会寻找一个“不体面”地“绕路”方法，经典的 C, C++, Java 三兄弟的软件生态已经说明这个问题了。[^3]

如何设计宏编程机制， 让它简单、方便、强大而又安全，Rust 已经做了一个很好的探索，但是还是有很大的规范化、标准化以及设计和实现方面的改进空间，这一点学术界应该进来做课题研究，如何定性和定量地分析编程语言语义的抽象能力，如何设计宏机制，让它能以最优雅的方式表达更高阶的抽象。


再比如，**模式匹配** ，它的起源应该是纯函数式语言的编译器前端为做形式推演而实现的功能，现在已经成为了所有主流编程语言的一个标准，在宏编程上更是必不可少的。

再比如， **结构化和富文本化的代码注解** ，支持和其他代码注解的内联和外联[^4]，支持基本的 Markdown 格式，支持 Latex 数学公式[^5]。[^6]

再比如，**内嵌的单元测试框架和性能基准测试框架** ，显然任何代码都离不开正确性测试和性能的基准测试，与其等别人做，不如自己做。

再比如，**调试友好** ，生成的可执行文件里有足够的调试信息供调试程序使用或开发人员阅读，以了解具体问题出在哪儿。


#### 复杂语言插件

编程语言的语言插件应该比编译器的前端实现更复杂。

曾几何时，对高级语言插件的要求还只是代码补完的层面，现代的编程语言插件应该至少有一个到语义分析层面的编译器的等价前端，它应该实现 VSCode 的 lanuage server protocol 的协议，做包括但不限于 **依赖分析**，**类型标明**，**语法和语义检查**，**代码自动生成**，**代码风格格式化** ， 等所有 rust-analyzer 做的事情，可以超过它，但不能少！


它可能需要与项目管理工具紧密地集成在一起。

#### 全过程管理工具

解决全过程的 **项目构建**，**依赖解决**，**程序调试**，**性能分析**，**编译打包**，**软件分发** 的工具。

#### 官方仓库

对所有人开放，但应该一开始就严肃对待其中安全问题，主要是代码上传者的身份认证问题。

#### 文档化

上述所有过程，都应该有**最新、最及时、最科学组织的文档**。

这对传统编程语言看起来很困难，但 Rust 基本做到了。


### 终极客户

#### 杀手级应用

成功的示范总是最好的宣传。[^7]

#### 或者其他

如果不是“天选”之人，不背靠大树，也没有技术转移，没有做出杀手级应用的条件，那就要走一条“凡人修仙”之路：

让产品能在终极客户那里**快速落地**，**满足需求**，提供及时的**后期保障**，甚至 **超前地解决问题** 。

这样，从重量级竞争对手所不重视的小客户和边缘地区开始，难怕开始时只是普通的产品，凭借服务质量，也可以一步步壮大，升级换代，这样成长起来的生态系统，根基非常深厚，同等级别对手是无法与它竞争的。[^8]

不过，怎么让终极客户取得成功并不是编程语言习惯上关心的事情，因为事实上也力有未逮而鞭长莫及。

但是，一方面，从根本上讲，关心终极客户是有理由的，因为最终编程语言的成功就在于它下游终极客户的成功；另一方面，如下一节 [生态位](#生态位) 所分析，编程语言去做这些事情可能也是有现实条件的。


### 生态位[^9]

#### 技术生态位

让我们先从 [快速启动](#快速启动) 一节里的技术问题，如果你是一门运行在虚拟机上的解释型语言，那你首先需要通过某个编译型语言编译一个目标平台上的虚拟机的二级制版本，然后才能在这个目标平台的虚拟机上运行你的字节码，那么你实质上就依赖这个编译型语言来编译你的虚拟机，你永远不能摆脱这种依赖，因为你的字节码不能直接运行在硬件上。

即使是编译型语言，也要看它的编译器是用什么语言实现的，有人说我是自举的，那我就想起一个亲身经历，关于 Go 的笑话[^13]：
1. 我想要在我的操作系统里安装 Go ，可是它是自举的，如果你的系统之前没有安装 Go ，那么你需要先安装一个较低版本的 Go ，才能通过它编译安装现行版本的 Go ；
2. 我从 Go 的代码仓库里检索到了一个允许升级新版本的最低版本的 Go，您猜怎么着，要安装这个版本 Go 的编译还需要一个更低版本的 Go ；
3. 就这样我沿着仓库的代码历史，一直找到一个不自举，用 C/C++ 实现的 GO 版本，通过安装它，然后逐步向上升级，才最终得到想要安装的、现行版本的 Go

这个谬论就好像虚拟机上的语言也可以声称自己是自举的，只要在虚拟机上实现一个虚拟机什么的。真正重要得是，你的编程语言是不是操作系统的源生语言!

不藏着掖着，直说了，**操作系统的开发语言就是编程语言里的“头等公民”**，在 Linux 系统里，就是 C ；

**加入内核开发工具链的，被允许通过二进制应用接口和内核通讯的，是“四舍五入”的“头等公民”**，在 Linux 系统里，就是 C++ ，后来 Rust 也加入了进去；

其他的在官方生态系统里的，有完备的预编译库支持的，就算“二等公民” ，Linux 里就是什么 Perl，Python 之流；

还有其他，就算“不入流”了。

也就是说，真正的系统级编程语言是和操作系统处在同一个生态位的，总是和具体硬件主要是 CPU 绑在一起。


#### 商业生态位

如果能够整合硬件和软件生态，形成完整封闭生态链，便可如苹果故事，昔日联想倪光南想干而被小人所害，三星想干而力有未逮，华为正在干，差不多已经干成了。

退而求其次，如果能和硬件厂商合作，形成联合垄断，也不失微软之位，这至少是小米所能争取的。

此两类都能形成自己的操作系统，也会出现自己的系统级开发语言[^14]，这都是顺便的事。


## 注解

[^1]: 让直接用户去解决编译器本身的复杂依赖是最坏的反例，但是你哪怕让我去手动配置下环境变量，我都觉得是费事儿。

[^2]: 搁这儿用人力节约算力呢，什么亏本的买卖？

[^3]: 曾经，很多 Lisp 方言会声称它们的语言特性使得宏机制很强大，但那是过时的观念，以我的经验看，经典的 Lisp 宏用起来既不方便，功能也不强大，并且由于其把文本解释成代码，更是犯了代码审计上的原罪（PHP罪）。

[^4]: 注解的互相引用方面 Java做得就挺好

[^5]: Rust 一开始支持丰富格式的注解，但是后来因为项目扯皮的原因把功能去掉了，把责任丢给了外部文档转换工具，但这不只是注解自动生成文档的问题，本来就有在编辑器上看注解里的数学公式的需求，特别是算法相关的代码。

[^6]: 另一方面，注解里的代码测试就挺鸡肋的，代码作者不应该依赖它做测试，而代码的引用者关注得是接口而不是代码的正确性。

[^7]: 但也有一条邪路，与其追求成功，不如追求不败，做杀手级应用比不上背靠大树好乘凉，如果你有像 Google 那样行业巨搫的背书，就算只是 60 分的产品，也直接等于 100 分。

[^8]: 这正是在所有独立自主的后发国家里成长出来的技术产品（公司）的发展路线

[^9]: 主要指有系统编程能力的编译型语言，它们是其他编程语言的上游

[^10]: PHP 好就好在可以把用户输入直接插进代码里执行，坏也坏在这上面，包括 Mybatis 也是这方面问题，这是机制缺陷，相当于为了图方便，直接在程序上开了一个 REPL 的接口来接受用户输入，这肯定不是体面的做法。但另一方面，我买了一本我们电子工业出版社出版的很厚很专业的网络安全攻防（CTF）教材，想着作为一个程序的开发者，怎么的也得了解一下这些网络安全方面的内容，结果打开一看，嗨，百分之九十九以上的内容都是 PHP ，讲来讲去就是怎么利用用户输入做代码注入，我想这要是没有 PHP ，我都不知道这些人吃什么去，对于其他竟品语言，因为有 PHP ，每一个人都可以讲一讲自己的安全性优势，哪怕只是相对于 PHP 的优势，这也是辨证地看问题。🤓

[^11]: 比如对经典基于指针共享的数据结构（树和图）支持的匮乏，官方提供的自动指针和内部可变结构的嵌套，很难用也不解决根本问题，最后只能借助宏机制大法来 workaround ，可以参考[我在二叉搜索树和B树上的实现文章来查看细节](https://minghu6.github.io/algs/BST-0-Basic.html)。

[^12]: 这也是 Mozilia 基金会和 Google 基金会资助的技术项目一贯地风格差异的对比，一个比较踏实，一个特别浮夸。

[^13]: 为什么一遇到 Go 总是没有好事呢？🤓

[^14]: 华为已经干得很好了，鸿蒙OS和仓颉系统开发语言，现在鸿蒙开发语言还是C/C++，等生态进一步成熟后必然要自举，那是真自举，因为硬件的全生态链都在自己的手里，有这个条件；而小米就差一点，毕竟主导地位不能与华为相比，只能走一条开放、合作的道路，但是搞一个自己的系统级开发语言也是迟早的事，因为也有这个条件。
